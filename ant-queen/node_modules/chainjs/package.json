{
  "name": "chainjs",
  "version": "0.1.10",
  "description": "Chainjs call each async function step by step, let async function callback fairily.",
  "main": "chain.js",
  "scripts": {
    "test": "mocha test/test.js",
    "cover": "jscoverage chain.js test/tmp/chain.js && npm run mocha-cover",
    "mocha-cover": "mocha -r jscoverage --covout=html test/cover.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/switer/chainjs.git"
  },
  "keywords": [
    "chain",
    "async",
    "callback",
    "javascript",
    "step",
    "flow",
    "control"
  ],
  "author": {
    "name": "switer"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/switer/chainjs/issues"
  },
  "devDependencies": {
    "chai": "^1.10.0",
    "colors": "^0.6.2",
    "jscoverage": "^0.5.9",
    "mocha": "^2.0.1"
  },
  "readme": "chainjs\r\n=======\r\n![logo](http://switer.qiniudn.com/chain.png)\r\n\r\nAn asynchronous callback's flow controller, chaining async function callbacks. Async methods calling flow make easy. I use it in node.js server and webapp.\r\n\r\n## Install\r\n\r\n```bash\r\nnpm install chainjs\r\n```\r\n\r\n## Usage\r\n\r\n__use in node:__\r\n```javascript\r\nvar Chain = require('chainjs')\r\n\r\nChain(function (chain) {\r\n        console.log('initialize');\r\n        chain.next('none');\r\n    })\r\n    .some(function (chain) {\r\n        chain.wait(300, 'then go to next in step 1')\r\n    }, function (chain) {\r\n        chain.wait(200, 'then go to next in step 2')\r\n    }, function (chain) {\r\n        chain.wait(100, 'then go to next in step 3')\r\n    })\r\n    .then(function (chain, data) {\r\n        console.log(data); // --> then go to next in step 3\r\n        chain.next('say hello');\r\n    })\r\n    .final(function (chain, data) {\r\n        console.log(data); // --> say hello\r\n    });\r\n```\r\n\r\n![diagram](http://switer.qiniudn.com/chainjs2.png)\r\n\r\n## API\r\nEach step's handler has been passed the `chain` instance as the first argument\r\n\r\n### Chain(func, func1, ..., funcN)\r\nInstancing a chain, if arguments is not empty, it will be call .then() with arguments automatically.\r\nIf first argument is type of `Array`, that argument will be passed as arguments.\r\n```javascript\r\nChain(func /*, func1, ..., funcN*/);\r\n// or \r\nChain([func, func1, funcN])\r\n```\r\n\r\n### .then(func, func1, ..., funcN)\r\nDefine a chain step, if a then step has multiple functions, it need each function call chain.next() to goto next step.\r\n```javascript\r\nChain().then(funcA1, funcA2, funcA3).then(func1)\r\n```\r\nIf first argument is type of `Array`, that argument will be passed as arguments.\r\n```javascript\r\nChain.then([func1, func2, ..., funcN])\r\n// equal to \r\nChain.then(func1, func2, ..., funcN)\r\n```\r\n\r\n\r\n### .retry()\r\nCall current function once again (use for recursive).\r\n```javascript\r\nvar flag\r\nChain(function (chain, data) {\r\n    if (flag) {\r\n        return chain.next()\r\n    }\r\n    flag = true\r\n    chain.retry()\r\n}).start('value')\r\n```\r\n\r\n### .some(func, func1, ..., funcN)\r\nDefine a chain step, if a then step has multiple functions, it need any function of this step calling chain.next() only once to goto next step.\r\n```javascript\r\nChain(func).some(function (chain) {\r\n    setTimeout(function () {\r\n        chain.next()\r\n    }, 100)\r\n}, function (chain) {\r\n    setTimeout(function () {\r\n        chain.next()\r\n    }, 1000)\r\n}, function (chain) {\r\n    setTimeout(function () {\r\n        chain.next()\r\n    }, 500)\r\n}).then(function () {\r\n    // this step will be run after 100ms.\r\n})\r\n```\r\nIf first argument is type of `Array`, that argument will be passed as arguments.\r\n```javascript\r\nChain.some([func1, func2, ..., funcN])\r\n// equal to \r\nChain.some(func1, func2, ..., funcN)\r\n```\r\n\r\n### .each(func, func1, ..., funcN)\r\nDefine a chain step, call each handlers of this step in sequence. In this step, each function call chain.next() to call next function. In orders from left to right of arguments\r\n```javascript\r\nChain(func).then(func1).each(funcA1, funcA2, funcA3)\r\n```\r\nIf first argument is type of `Array`, that argument will be passed as arguments.\r\n```javascript\r\nChain.each([func1, func2, ..., funcN])\r\n// equal to \r\nChain.each(func1, func2, ..., funcN)\r\n```\r\n\r\n### .start(data, data1, ..., dataN)\r\nStart running the chain, and could pass data to initial step.\r\n```javascript\r\nChain(function (chain, initData) {\r\n    \r\n}).then(func1).then(func2).start(initData);\r\n```\r\n\r\n### .destroy()\r\nDestroy the chain, mark the chain as ending and destroy local variable, but don't calling final funtions.\r\n\r\n__notice:__ after use chain.destroy(), the chain contiue execute current step handler, \r\nso use with return for stoping current step excution\r\n```javascript\r\nChain(func).then(function (chain) {\r\n    chain.destroy();\r\n    return;\r\n}).start();\r\n```\r\n\r\n### .next(data, data1, ..., dataN)\r\nGo to next step\r\n```javascript\r\nchain.next();\r\n// pass params to next step handler\r\nchain.next(data);\r\n```\r\n\r\n### .branch(branchName, func)\r\nDefine a branch step, only using `chain.nextTo(branchName)` to goto branch step. \r\nCall `chain.next()` from last step will skip next branch step.\r\n```\r\n     -------------o\r\n     |            â†“\r\no----o----->o---->o---->o\r\n```\r\n\r\n```javascript\r\nChain(function (chain) {\r\n    chain.nextTo('branchA')\r\n    chain.next()\r\n}).then(function (chain) {\r\n    throw new Error('This step should not be called')\r\n}).branch('branchA', function (chain) {\r\n    chain.next()\r\n}).branch('branchB', function (chain) {\r\n    throw new Error('This step should not be called')\r\n}).final(function (chain) {\r\n    // done\r\n}).start()\r\n```\r\n\r\n### .nextTo(branchName, data, data1, ..., dataN)\r\nGo to next branch.\r\n```javascript\r\nChain(function (chain) {\r\n    chain.nextTo('branchA')\r\n}).then(function (chain) {\r\n    throw new Error('This step should not be called')\r\n}).branch('branchA', function (chain) {\r\n    chain.next()\r\n})\r\n```\r\n**Notice**: .nextTo() should not goto previous step\r\n```javascript\r\nChain(function (chain) {\r\n    chain.next()\r\n}).branch('branchA', function (chain) {\r\n    chain.next()\r\n}).then(function (chain) {\r\n    chain.nextTo('branchA') // will throw an error\r\n}).start()\r\n```\r\n\r\n### .wait(time, data, data1, ..., dataN)\r\nWaiting some time then call next step.Just a shortcut of `setTimeout(function () {chain.next()}, time)`.\r\n```javascript\r\n// pass params to next step handler\r\nchain.wait(5000, data); // wait 5s then call next\r\n```\r\n\r\n### .end(data, data1, ..., dataN)\r\nEnd up chain steps, mark the chain as ending, for cross steps data sharing\r\n```javascript\r\nchain.end();\r\n// pass params to final handler\r\nchain.end(data);\r\n```\r\n\r\n### .final(finalHandler)\r\nDefine a final step, witch will be invoke after call chain.end() or all step of this chain is over.\r\n```javascript\r\nChain(function (chain) {\r\n    ...\r\n    chain.end('ending initial step')\r\n\r\n}).then(function (chain) {\r\n\r\n    ...\r\n    chain.next('step 2 calling')\r\n\r\n}).final(function (chain, data) {\r\n    console.log(data) // --> ending initial step\r\n})\r\n```\r\n\r\n### .data(savingData)\r\nSaving data in current chain\r\n```javascript\r\n// set data\r\nchain.data('param', param);\r\n// set multiple data in batch\r\nchain.data({\r\n    'param1': param1,\r\n    'param2': param2,\r\n    'param3': param3\r\n});\r\n// get data\r\nchain.data('param');\r\n// get all data\r\nvar chainData = chain.data();\r\n```\r\n\r\n### .thunk(func)\r\nTurn a regular node function into chainjs thunk.\r\n```javascript\r\n function handler1 (param, callback) {\r\n    callback(param + 'Chain through step1, ')\r\n}\r\nfunction handler2 (param, callback) {\r\n    callback(param + 'step2')\r\n}\r\nChain()\r\n    .then(Chain.thunk(handler1))\r\n    .then(Chain.thunk(handler2))\r\n    .final(function (chain, data) {\r\n        console.log(data); // --> Initialize! Chain through step1, step2\r\n    })\r\n    .start('Initialize! ')\r\n```\r\n\r\n### .context(ctx)\r\nBinding \"this\" to specified ctx for all functions of each step of current chain. \r\n```js\r\nChain(function () {\r\n    console.log(this); // --> \"abc\"\r\n})\r\n.then(function () {\r\n    console.log(this); // --> \"abc\"\r\n})\r\n.context('abc')\r\n.start()\r\n```\r\n\r\n## Testing\r\nChainjs using [mocha](http://mochajs.org/) for BDD test, run below cli to run testing in nodejs\r\n```bash\r\nnpm test\r\n```\r\n\r\n## Example\r\nSee [using chainjs control business logic flow example](https://github.com/switer/chainjs-flow-control-demo)\r\n\r\n```javascript\r\nvar Chain = require('chainjs');\r\nvar someStepCount = 0;\r\nvar parallelCount = 0;\r\n\r\nChain(function (chain) {\r\n        // save param\r\n        chain.data('chain:param', 'Chain initial step data');\r\n        chain.next({message: 'Next step'});\r\n    })\r\n    .some(function (chain, param) {\r\n        someStepCount ++;\r\n        chain.wait(2000, 'step is \"some-1\"');\r\n    }, function (chain, param) {\r\n        someStepCount ++;\r\n        chain.wait(1000, 'step is \"some-2\"');\r\n    })\r\n    .then(function (chain, msg) {\r\n        console.log(msg); // step is \"some-2\r\n        // Step over when last step has one hander called\r\n        console.log(someStepCount); // 1\r\n        chain.next();\r\n    })\r\n    .then(function (chain) {\r\n        parallelCount ++;\r\n        chain.next();\r\n    }, function (chain) {\r\n        parallelCount ++;\r\n        chain.next();\r\n    }, function (chain) {\r\n        parallelCount ++;\r\n        chain.next();\r\n    })\r\n    .then(function (chain) {\r\n        // all handlers had been called in last step\r\n        console.log(parallelCount); // 3\r\n        chain.end();\r\n    })\r\n    .then(function (chain) {\r\n        //prev step had call chain.end(), so this step will be skiped\r\n    })\r\n    .final(function (chain) {\r\n        var param = chain.data('chain:param');\r\n        console.log(param); // \"Chain initial step data\"\r\n    })\r\n    .context(this)\r\n    .start(); // starting chain execute\r\n```\r\n\r\n## Change Log\r\n\r\n[See change logs](https://github.com/switer/chainjs/blob/master/CHANGELOG.md)\r\n\r\n## License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013 `guankaishe`\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n",
  "readmeFilename": "README.md",
  "_id": "chainjs@0.1.10",
  "dist": {
    "shasum": "b7f114cdcc3fa155eb47705d2d0eddfe4453daf8"
  },
  "_from": "chainjs@0.1.10",
  "_resolved": "https://registry.npmjs.org/chainjs/-/chainjs-0.1.10.tgz"
}
